/*
* @name bison.yy
* @description A Simple Tools of Expression Analysis
* @date 03/26/2020 
* @author Lrq
*/

%language "C++"
%defines
%locations
%skeleton "lalr1.cc"
%debug 

%code{
	#include <iostream>
	#include <unistd.h>
	int yydebug=1;
}

%code requires{
	#define YYDEBUG 1
	#include "ast.h"
	#include "visitor.h"
	#include "codegen.h"
}
%union{
	AstNode* a;
	Expression* e;
	Identifier* id;
	Statement* stmt;
	vector<Statement*>* stmt_decl_list;
	vector<Variable*>* variable_list;
	vector<Expression*>* arg_list;
	Int10* int10;
	Real10* real10;
	Assign* assign;
	IfStmt* If;
	PrimitiveType* type;
	Variable* variable;
	Function* function;
	int n;
	double d;
}

%parse-param {Expression** root} {Statement** stmt}

/* declearation */
%token END_OF_FILE
%token EOL
%token REAL8 REAL16
%token REAL10 
%token <e> INT8 INT16
%token <int10> INT10 
%token <e> ADD SUB MUL DIV 
%token <assign> ASSIGN
%token <If> IF
%token LP RP MLP MRP LLP LRP 
%token WHILE DO ELSE RETURN TYPE_INT TYPE_VOID TYPE_FLOAT
%token LT GT  SEMICOLON COMMA
%token EQ GET LET NEQ
%token <id> ID

%type <e> expression simple_expression relop additive_expression addop term mulop factor call
%type <stmt> expression_stmt statement compound_stmt selection_stmt 
			 iteration_stmt return_stmt var_declearation fun_declearation 
			 declearation
%type <type> type_specifier
%type <variable> param
%type <variable_list> param_list params 
%type <arg_list> arg_list args
%type <stmt_decl_list> local_declearations statement_list declearation_list program
%type <id> var
%{
	extern int yylex(yy::parser::semantic_type *yylval, yy::parser::location_type *yylloc);
%}

%%
	program: declearation_list {
								$$ = $1;
								Gen::genCode($1);
							}
	       ;

	declearation_list: declearation_list declearation{
													  $1->push_back($2);
													  $$ = $1;
												}
					 | declearation {
									$$ = new vector<Statement*>();
									$$->push_back($1);
									
								}
					 ;

	declearation: var_declearation {$$ = $1;}
				| fun_declearation {$$ = $1;}
				;

	var_declearation: type_specifier ID SEMICOLON {$$ = new Variable($1, $2, "local_id_var");}
					| type_specifier ID MLP INT10 MRP SEMICOLON //{$$ = new ArrayVariable($1, $2, "local_arr_var");}
					;

	type_specifier: TYPE_INT {$$ = new PrimitiveType("int");}
				  | TYPE_FLOAT{$$ = new PrimitiveType("float");}
				  | TYPE_VOID {$$ = new PrimitiveType("void");}
				  ;

	fun_declearation: type_specifier ID LP params RP compound_stmt{
																	$$ = new Function($1, $2, $4, $6, "Function");
																	/* As for code generation, we only need
																	   function name($2) and function body($6) */
																	Gen::genFunction($$, $2, $6);
																};

	params: param_list {$$ = $1;}
		  | TYPE_VOID  {
						/* Empty param list */
						$$ = new vector<Variable*>();
					}
		  ;

	param_list: param_list COMMA param{
										$1->push_back($3);
										$$ = $1;
									}
			  | param {$$->push_back($1);}
			  | {$$ = new vector<Variable*>();}
			  ;

	param: type_specifier ID {$$ = new Variable($1, $2, "param_id_var");}
		 | type_specifier ID MLP MRP//{$$ = new ArrayVariable($1, $2, "param_arr_var");} 
		 ; 

	compound_stmt: LLP local_declearations statement_list LRP {
										/* Need to pass ($2, $3)->code to $$->code (implemented in construct function) */
															  $$ = new BlockStmt("block", $2, $3);
														}
				 ;
	
	local_declearations: local_declearations var_declearation{
															 $1->push_back($2);
															 $$ = $1;		
														}
					   | {$$ = new vector<Statement*>();}
					   ;

	statement_list: statement_list statement {
											 $1->push_back($2);
											 $$ = $1;
										}
				  | {$$ = new vector<Statement*>();}
				  ;

	statement: expression_stmt {$$ = $1;} 
			 | compound_stmt {$$ = $1;}
			 | selection_stmt {*stmt = $1; $$ = $1;}
			 | iteration_stmt
			 | return_stmt
			 ;

	expression_stmt: expression SEMICOLON {
						/* Need to pass $1->code to $$->code (implemented in construct function) */
											$$ = new ExpStmt("exp", $1);
											$$->code = $1->code;
										}
				   | SEMICOLON {$$ = new EmptyStmt("empty");}
				   ;


	selection_stmt: IF LP expression RP	statement{
												     $$ = new IfStmt("if", $3, $5); 
													 Gen::genIfStmt($1, $3, $5);
													 $$ = $1;
												 }
				  | IF LP expression RP statement ELSE statement{
																    $$ = new IfStmt("if", $3, $5, $7);
																	Gen::genIfStmt($1, $3, $5, $7);
																	$$ = $1;
																}
	
	
	iteration_stmt: WHILE LP expression RP statement{
													 	$$ = new WhileStmt("while", $3, $5);
													}
				  ;
	
	return_stmt: RETURN SEMICOLON {}
	           | RETURN expression SEMICOLON {}
			   ;

	expression: var ASSIGN expression {
										$2 = new Assign("=", $1, $3);
										Gen::genAssign($2, $1, $3);
										$$ = $2; 
										*root = $2; 
									  }
	          | simple_expression
			  ;

	var: ID { Gen::genId($$, $1); $$ = $1;}
	   | ID MLP expression MRP
	   ;
	
	simple_expression: additive_expression relop additive_expression{
																		$2->left = $1; 
																		$2->right = $3; 
																		Gen::genRelop($2, $1, $3, $2->type);
																		$$ = $2;
																	}
					 | additive_expression
					 ;

	relop: GT { $$ = new BinOp(">");}
		 | LT { $$ = new BinOp("<");}
		 | LET { $$ = new BinOp("<=");}
		 | GET { $$ = new BinOp(">=");}
		 | EQ { $$ = new BinOp("==");}
		 | NEQ { $$ = new BinOp("!=");}
		 ;	
	
	additive_expression: additive_expression addop term {
															$2->left = $1; 
															$2->right = $3; 
															Gen::genBinary($2, $1, $3, $2->type);
															$$ = $2;
														}
					   | term 
					   ;
	
	addop: ADD { $$ = new BinOp("+");}
	     | SUB { $$ = new BinOp("_");}
		 ;

	term: term mulop factor {
								$2->left = $1;
								$2->right = $3;
								Gen::genBinary($2, $1, $3, $2->type);
								$$ = $2;
							}
	    | factor 
		;
	
	mulop: MUL { $$ = new BinOp("*");}
	     | DIV { $$ = new BinOp("/");}
		 ;

	factor: LP expression RP {$$ = $2;}
	      | var {$$ = $1;} 
		  | call {$$ = $1;}
		  | INT10 {Gen::genInt10($$, $1); $$ = $1;}
		  ;

	call: ID LP args RP {
						   $$ = new FunctionInvocation($1, $3, "invoke");
						   Gen::genFunctionInvoke($$, $1, $3);
						}
		;

	args: arg_list {$$ = $1;}
	    | {$$ = new vector<Expression*>();};

	arg_list: arg_list COMMA expression {
											$1->push_back($3);
										}
			| expression {
						    $$ = new vector<Expression*>();
							$$->push_back($1);
						}
			;

%%

namespace yy{
	void
	parser::error(location const &loc, const std::string &s){
			std::cerr << "error at " << loc << ": " << s << std::endl;
	}
}
